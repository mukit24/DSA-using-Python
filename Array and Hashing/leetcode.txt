problem: 217
* Brute Force [O(n^2) time and O(1) space]: Compare every pair of elements.
* Sorting [O(nlogn) time]: Sort the array, and then check consecutive elements for equality. Space complexity will be O(1) if using heap sort or inplace quick sort.
* HashSet [O(n)]: As you iterate through the array, add each element to a set. If an element is already in the set, return true.

problem: 242
* Sorting [O(nlogn) time and O(n) space]: If anagaram then sorting of both string will be same.
* HashMap [O(n) time & O(1) space bcz fixed 26 char]: HashMap to count character in 1st string. Then loop through 2nd string and check if not exist or its frequency is 0 then return False. Otherwise just decrement the count. If anagram then all values of hashMap will be zero. Alternating approach will be using a character array or built in Counter class.

problem: 1
* Brute Force: Check all pairs of numbers to see if they sum to the target.
* HashMap [O(n)]: Iterate and add in hashMap (key: num, value: index). And check (target - num) present in the hashMap. If found then return their indices.

problem: 238
* can be solved by brut force using 0(n^2)
* another way is, get the total product value. Then just lopp through a divide total product value by current value.
* optimize solution is using prefix and suffix:
[1,2,3,4]
suppose current value is 2. so the prefix is 1 and suffix is 3*4=12
so, ans in that position is prefix * suffix.

problem: 128
* can be solved by sorting. In sorted a list, traverse and check current = current -1 and count.
* convert to set. Traverse and check for is it the starting point of a sequence(if element-1 not exist then it is starting point). If starting point found then apply while loop for element+1 and count. max count is the answer.
* another way is - convert to set. Traverse and check element+1 or element-1 is exist or not. if exist then apply while loop accordingly and get the max count.
*** check for complexity in last two approach. It is O(n). bcz inner while execute each element just once for all outer iteration.