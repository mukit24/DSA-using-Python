Problem: 2529
use two loop. First count 0 as positive then in second loop count 0 as negative.

problem: 153
* Main logic in rotating_list.py file. Second submission applies another improved logic. If list[mid] > list[hi] then solution lies in right half except mid. so lo = mid + 1. Else solution lies in left half with mid. so hi = mid.

problem: 33
* Brute Force: Check every element.
* Binary Search: Remember rotated sorted array? If mid == target then return its index. Now think of which half will we go? 1st identify which half is properly sorted? If lo <= mid, it means left half is sorted. Now check if lo <= target < mid, then we should go to the left half. Otherwise right half. Think same when right side is properly sorted.

problem: 74
* O(log(m*n)) Solution: Seems easy by looping through each row and then apply binary search in it Or Think 2D in 1D(lo = 0 and hi = rows * cols - 1. Now apply normal binary search. But how do we get the mid_value by index? mid_value = matrix[mid//cols][mid%cols]).
* O(log(m+n)): There is optimize way. We don't need to search every row. If target is exist in an row then that row's: 1st element <= target <= last element. So 1st apply binary search to locate the row. Then Apply binary search again on that row to get the target.

problem: 374
* Same as binary search to find target but a generalized way. Guess function handle the condition checking like mid == target, mid < target etc. Then it return 3 values. Upon these values we use them to half the range.

problem: 278
* We switching hi/lo values, always use hi = mid (when mid is true. By doing this we are always at the first occurance of true). (think).
* We can use that technique when answer is always present in the array.

problem: 162
* Brute Force: Check every number that it is greater than its neighbor. (handle first and last element also).
* Binary Search: Hard to get the intuition. But look closely. If right value of mid is greater what it means? Either it will be in increasing order or sometimes it will decrease (as two neighbor can't have same value). So either case we have an answer. Same goes for left side. 

problem: 875
* Brute Force [O(n * max(piles))]: Possible k ranges from 1 to max(piles). We can bruteforce 1 to max(piles). If total time using that k is less than h then it is the answer.
* Binary Search [O(n * log(max(piles)))]: For optimization, we can implement binary search in possible k values. If mid satisfy the condition then minimum k is present in the left half. Else right half.
* Alt solution but not optimize:
    avg speed = sum(piles)/h
    k must be equal to avg speed or greater.
    So, we can change the lo to average speed.
    calculating sum(piles) takes O(n times) so it is not optimized.

problem: 981
* How to store key-value pairs? First thing will come upto my mind is hashmap. But here multiples values can be in same key. So use an array for value in hashMap (key: [[val, time],...]). Now think of get. We can apply a linear search on the appropiate values array to get the desirable ans. But we can optimize this search by using binary search as timestamp is in increasing order.

problem: 4
* Brute Force [O((n+m)* log(m+n))]: Just add two list and sort them. Then find median.
* Two Pointer [O(m+n)]: Remember merge two sorted array problem? We can merge two sorted list using two pointer. Then find the median in merged array.
* Binary Search: Implement Later.




