Problem: 2529
use two loop. First count 0 as positive then in second loop count 0 as negative.

problem: 153
main logic in rotating_list.py file. second submission applies another improved logic.
if list[mid] > list[hi] then solution lies in right half except mid. so lo = mid + 1
else solution lies in left half with mid. so hi = mid

problem: 33
* if mid == target then return its index. 
* Then check if mid element is greater than or equal to low element. If true then means left side is properly sorted.(for ex - [3,4,5,6,1]). Now if target is greater than the mid it means target must be present in the right side. For less, it can be on both sides. If it is less than low it means the target is in right side otherwise left.
* for else, [5,6,1,2,3] use this and think the opposite.


problem: 74
* O(log(m*n)) Solution: Seems easy by looping through each row and then apply binary search in it Or Think 2D in 1D(lo = 0 and hi = rows * cols - 1. Now apply normal binary search. But how do we get the mid_value by index? mid_value = matrix[mid//cols][mid%cols]).
* O(log(m+n)): There is optimize way. We don't need to search every row. If target is exist in an row then that row's: 1st element <= target <= last element. So 1st apply binary search to locate the row. Then Apply binary search again on that row to get the target.

problem: 374
* Same as binary search to find target but a generalized way. Guess function handle the condition checking like mid == target, mid < target etc. Then it return 3 values. Upon these values we use them to half the range.

problem: 875
possible k ranges from 1 to max(piles). We can bruteforce 1 to max(piles). if total time using that k is less than h then it is the answer (#condition).
For optimization, we can implement binary search in possible k values. If mid satisfy the #condition then minimum k is present in the left half. Else right half.
* O(log(max(piles)) * len(piles))

Alt solution but not optimize:
avg speed = sum(piles)/h
k must be equal to avg speed or greater.
So, we can change the lo to average speed.
* calculating sum(piles) takes O(n times) so it is not optimized.


