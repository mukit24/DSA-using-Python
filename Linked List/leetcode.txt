problem: 206
* Iterative [O(n) time]: Just iterate and reverse the pointer. At a certain node we need the previous node for reversing. So use a prev pointer(initially None) along with current. 

Problem: 21
* each iteration check one from both list. if list1.val < list2.val then ansList.next = list1 and list1 = list1.next . vice verse.
* for deifferent size one will not be traversed full. Just join that remaining portion with ansList.
* complexity O(size(list1)+size(list2)) or O(N) here N is total number of nodes across both list.

problem: 143
* Using List: Append every node in a list. Then use two pointer (l, r) - one at start and one at last. Using two pointer, alternatively link r and l.
* Linked List: We want value from last as well. But there is no way to backward traverse in single linked list. So we reverse the second half of the list. Now using two pointer (one at head, other at last node of linked list or head of 2nd half), we can alternatively link both pointer.

problem: 19
* Two Pass: Iterate through linked list and count node. Then identify the position (position = Length - n). Again loop through to get the position and delete node.
* One Pass: Use two pointer (first and second) both starting at a dummy node. Maintain a gap of n+1 steps between two pointer. Then increment both pointer. When first pointer reaches end then the second pointer will be at appropiate postion. Then delete node.

Problem: 23
* now we merge k sorted list. Think of two sorted list problem. We can do a bruth force. Loop through all lists and merge it with the currently merged list using two sorted list problem solution. At the end we find the answer. time complexity will be O(kN), here k is the number of list and N is the total number of nodes across all lists.

* we can do better by minimizing the k iteration. How? think of merge sort. We can merge by pair then merge these pair again pair wise using that two sorted list problem. at last iteration we reached our answer. Suppose we have 8 lists. 1st iteration we got 4 list. 2nd iteration we got 2 lists and in 3rd we got one. So total 3 iteration. So k is minimized to logk. So the overall time complexity will be O(Nlogk).

* There is a heap solution. Check heap section.

problem: 328
* Using Two Pointer: First check head or head.next is null to avoid the edge cases. Then separate the list into two sub list. Use two pointer: odd (in head) and even (in head.next). Save even_head to link the sub lists. Now execute while loop untill even and even.next is true. Each iteration link odd.next = even.next then shift odd then even.next = odd.next and shift even. After loop, link odd.next = even_head.
* Without Two Pointer: Create dummy list for odd and even. Then iterate through linked list and link current node with odd or even list (depending is it odd or even - use flag to identify current is even or odd). After looping, join both list.

-->> Slow and Fast Pointer(Floyd's Hare and Tortoise Algorithm)

problem: 876
* Both start at head. Increase fast pointer 2 steps in each iteration and slow pointer 1 step. When fast pointer reaches end (fast and fast.next true) then Slow will be pointing at middle.
* Note: If even list then middle will be two nodes. According our algorithm we will end up at the 2nd middle node for even list. However, we can get the first middle node if we start fast pointer at head.next.

problem: 2095
* Use F&S technique to identify the middle. Use prev to identify the position before middle. Then delete the desirable node.

problem: 141
* Same as 876. Just check when slow == fast.

problem: 142
* Use F&S pointer technique to identify the Cycle. Now, place another slow pointer to head. Increase both Slow pointer one step. At a point theu will meet. That point will be the start of the cycle. There is a mathematical prove. Think that.
* We can solve this using extra memory without F&S technique. Just use a hashmap for visited nodes.
