problem: 206
* Iterative [O(n) time]: Just iterate and reverse the pointer. At a certain node we need the previous node for reversing. So use a prev pointer(initially None) along with current. 

Problem: 21
* each iteration check one from both list. if list1.val < list2.val then ansList.next = list1 and list1 = list1.next . vice verse.
* for deifferent size one will not be traversed full. Just join that remaining portion with ansList.
* complexity O(size(list1)+size(list2)) or O(N) here N is total number of nodes across both list.

problem: 143
* Using List: Append every node in a list. Then use two pointer (l, r) - one at start and one at last. Using two pointer, alternatively link r and l.
* Linked List: We want value from last as well. But there is no way to backward traverse in single linked list. So we reverse the second half of the list. Now using two pointer (one at head, other at last node of linked list or head of 2nd half), we can alternatively link both pointer.

problem: 19
* Two Pass: Iterate through linked list and count node. Then identify the position (position = Length - n). Again loop through to get the position and delete node.
* One Pass: Use two pointer (first and second) both starting at a dummy node. Maintain a gap of n+1 steps between two pointer. Then increment both pointer. When first pointer reaches end then the second pointer will be at appropiate postion. Then delete node.

Problem: 23
* now we merge k sorted list. Think of two sorted list problem. We can do a bruth force. Loop through all lists and merge it with the currently merged list using two sorted list problem solution. At the end we find the answer. time complexity will be O(kN), here k is the number of list and N is the total number of nodes across all lists.

* we can do better by minimizing the k iteration. How? think of merge sort. We can merge by pair then merge these pair again pair wise using that two sorted list problem. at last iteration we reached our answer. Suppose we have 8 lists. 1st iteration we got 4 list. 2nd iteration we got 2 lists and in 3rd we got one. So total 3 iteration. So k is minimized to logk. So the overall time complexity will be O(Nlogk).

* There is a heap solution. Check heap section.

-->> Slow and Fast Pointer
