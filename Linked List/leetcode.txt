problem: 206
* Iterative [O(n) time]: Just iterate and reverse the pointer. At a certain node we need the previous node for reversing. So use a prev pointer(initially None) along with current. 

Problem: 21
* each iteration check one from both list. if list1.val < list2.val then ansList.next = list1 and list1 = list1.next . vice verse.
* for deifferent size one will not be traversed full. Just join that remaining portion with ansList.
* complexity O(size(list1)+size(list2)) or O(N) here N is total number of nodes across both list.

problem: 143
* Using List: Append every node in a list. Then use two pointer (l, r) - one at start and one at last. Using two pointer, alternatively link r and l.
* Linked List: We want value from last as well. But there is no way to backward traverse in single linked list. So we reverse the second half of the list. Now using two pointer (one at head, other at last node of linked list or head of 2nd half), we can alternatively link both pointer.

problem: 19
* Two Pass: Iterate through linked list and count node. Then identify the position (position = Length - n). Again loop through to get the position and delete node.
* One Pass: Use two pointer (first and second) both starting at a dummy node. Maintain a gap of n+1 steps between two pointer. Then increment both pointer. When first pointer reaches end then the second pointer will be at appropiate postion. Then delete node.

Problem: 23
* now we merge k sorted list. Think of two sorted list problem. We can do a bruth force. Loop through all lists and merge it with the currently merged list using two sorted list problem solution. At the end we find the answer. time complexity will be O(kN), here k is the number of list and N is the total number of nodes across all lists.

* we can do better by minimizing the k iteration. How? think of merge sort. We can merge by pair then merge these pair again pair wise using that two sorted list problem. at last iteration we reached our answer. Suppose we have 8 lists. 1st iteration we got 4 list. 2nd iteration we got 2 lists and in 3rd we got one. So total 3 iteration. So k is minimized to logk. So the overall time complexity will be O(Nlogk).

* There is a heap solution. Check heap section.

problem: 328
* Using Two Pointer: First check head or head.next is null to avoid the edge cases. Then separate the list into two sub list. Use two pointer: odd (in head) and even (in head.next). Save even_head to link the sub lists. Now execute while loop untill even and even.next is true. Each iteration link odd.next = even.next then shift odd then even.next = odd.next and shift even. After loop, link odd.next = even_head.
* Without Two Pointer: Create dummy list for odd and even. Then iterate through linked list and link current node with odd or even list (depending is it odd or even - use flag to identify current is even or odd). After looping, join both list.

problem: 138
* Using HashMap: We can easily make copy of node using val. But what about next and random? That's the main challenge. For example, we copy a node from existing node. How can we place random? It may be not created yet. So at first, we need to create all nodes and map them to the existing node using hashmap for retriving their next and random. Then in second loop, we connect the next and random pointer of the new nodes by getting next and random from map.
* Interleave Node with O(1) Space: A->B->C to A->A'->B->B'->C->C'. Can we place new node after the existing node like this? Then we will set the new nodes random pointers. At last, we will separate the new nodes from the merged list.

problem: 2
* Think of addition operation. We start from the right then go to left. In that problem numbers already in reverse order, that make our life easier. So, start from head of both list. Add them and save the result in new node with carry handling (calculate total like this: n1 + n2 + carry). Go on.

problem: 445
* Same as problem '2' except numbers are not in reverse order. So, we can use stacks to simulate that reverse order and use same operation on stacks.

problem: 146
* HashMap + Double Linked List: We we save the key-value in hashMap then we can do get operation in O(1) time. What about put? It still O(1) if capacity is in limit. But problem is when capacity crosses we need to adjust our cache (least recent element will be removed). How to handle this? We can handle that using a double linked list(just store key). When to do a get or put, that node is become recent node. So we add them in the tail of the linked list. So head will be least recent. Hence, when capacity exceeds we will remove node from the head. As double linked list, insert and remove from both end will be done in O(1) time. Insert and remove can be called in both get and put. So, write two separate function for insert and remove.

problem: 25
* We know how to reverse linked list. But this this time we need to do it in group wise. In while loop, first check for group. If availabe group is not possible then return adjusted head. Else, identify group. Also, save that group start and end point. Reverse that group then adjust the group connection using start and end point.
* Using Stack: Same mechanism like previous. But this time, We can store the groups node in stack. Popping from stack to get the reverse order.

-->> Slow and Fast Pointer(Floyd's Hare and Tortoise Algorithm)

problem: 876
* Both start at head. Increase fast pointer 2 steps in each iteration and slow pointer 1 step. When fast pointer reaches end (fast and fast.next true) then Slow will be pointing at middle.
* Note: If even list then middle will be two nodes. According our algorithm we will end up at the 2nd middle node for even list. However, we can get the first middle node if we start fast pointer at head.next.

problem: 2095
* Use F&S technique to identify the middle. Use prev to identify the position before middle. Then delete the desirable node.

problem: 141
* Same as 876. Just check when slow == fast.

problem: 142
* Use F&S pointer technique to identify the Cycle. Now, place another slow pointer to head. Increase both Slow pointer one step. At a point theu will meet. That point will be the start of the cycle. There is a mathematical prove. Think that.
* We can solve this using extra memory without F&S technique. Just use a hashmap for visited nodes.
