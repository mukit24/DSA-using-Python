problem: 643
* Sliding Window [O(n) time]: Similar to Maximum sum subarray of size ‘K’ problem except when return just canculate max_sum/k. We can use slightly different code, Calculate the 1st k elements sum and assign it to max_sum and cur_sum. Now loop through from k to end. Calculate cur_sum by adding current and removing the element(i-k). Check for max sum and at last return max_sum / k.

problem: 2461
* Sliding Window + HashSet [O(n) time & O(k) space]: think of Maximum Sum Subarray of Size k problem. Only difference is that window must contain unique elements. Maintain a hash set for current window. In each iteration, 1st check for duplicates. Remove value from hashSet and current_sum and increase left pointer untill all are distict in the current window. Then calculate current sum and add current num in hashSet. When window size is equal to k, calculate the max sum and do other neccessay operation(remove from current  sum and hashSet, increase left pointer). 

problem: 1456
* Same as Maximum Sum Subarray of Size k. Just count the current_vowel and max_vowel instead.

problem: 219
* Sliding Window + HashSet [O(n) time & O(k) space]: Same elements should be in the window of size k. So, use a hashset for window. Loop and check if current is already exist on window set then return True. When window size exceed k then remove left element from set and increment the left pointer.
* HashMap [O(n) time & space]: This approach need less operations though time complexity is same as previous. Loop and add each number with their position. When a number already exist in the hash map then check i - hashMap[nums[i]] <= k. If that the case then return true.

problem: 567
* remember anagram? permutation is just like anagrams. so we can bruthforce in sliding window. use sliding window in s2 with window size of len(s1). then check each character of s1 and window. Its O(m*n). We can do another way by sorting the window and s1 then check. So its O(mlogm * n). Now Let's move to O(n) solution.
*  Character in the both string is limited to a-z. So we can use a fixed size(26) array or a hashmap to count each frequency. For array we need ascii value, for hashmap we can simply count freq in key-val pair. When both s1 freq and window freq is equal then we found the permutations.
* A variation can be applied bby using only one fixed array or hashmap. We need to adjust the s1 freq in every window. when the s1 freq is all zero then its true.
* One important note, using fixed size array is more performance friendly then hashmap. while both are O(1) in lookup(for array its index lookup) but the hashmap constant factors are overhead because its dynammic nature, hashing, mermory allocation etc. For example arr[1] is efficent more than hashmaplook because hashmap applies hash function in lookups. 